#' Plot Peptide Elution Profiles per Protein without and with Filters Applied
#' @description Native elution profiling data can be noisy. To suppress noise and select for the high quality signals, filters can be applied.
#'        This function wraps the filtering functions filterConsecutiveIdStretches() and filterByPeptideCorrelation() and visualizes their impact
#'        on protein elution profiles by combined plots of all peptides of a protein over the elution fraction number.
#' @import data.table
#' @param traces A traces object containing $peptide.profiles data.table with protein_id and peptide_id col
#' @param traces.sf A traces object containing stretch-filtered $peptide.profiles as generated by filterConsecutiveIdStretches().
#'        data.table with protein_id and peptide_id col. If not provided, it is generated.
#' @param sf_setting min_stretch_length setting that is used to generate the stretch-filtered peptide traces data if not provided.
#'        Defaults to 3.
#' @param traces.cf A traces object containing correlation-filtered $peptide.profiles as generated by filterByPeptideCorrelation()
#'        data.table with protein_id and peptide_id col. If not provided, it is generated.
#' @param cf_setting average_corr_cutoff setting that is used to generate the correlation-filtered peptide traces data if not provided.
#'        Defaults to 0.2.
#'
#' @return A data.table with the number of proteins and peptides remaining after filtering.
#'         Generates a FilterImpact.pdf in the working folder.
#'
#'
#' @examples
#' # NOT RUN:
#' # filterImpactNumbers <- plotFilterImpact(peptide.traces)
#' @export

plotFilterImpact <- function(traces, traces.sf = NULL, sf_setting = 3, traces.cf = NULL, cf_setting = 0.2){
  peptide.traces <- traces[[1]]
  if(is.null(traces.sf)){
    peptide.traces.sf <- filterConsecutiveIdStretches(traces, min_stretch_length = sf_setting)[[1]]
  } else {peptide.traces.sf <- traces.sf[[1]]}
  if(is.null(traces.cf)){
    peptide.traces.cf <- filterByPeptideCorrelation(traces, average_corr_cutoff = cf_setting)[[1]]
  } else {peptide.traces.cf <- traces.cf[[1]]}

  # plot
  prots <- unique(peptide.traces$protein_id)
  nprots <- length(prots)
  pdf(file = "protplots_filterimpact.pdf", height = 10)
  par(mfrow = c(3,1))
  for (i in 1:nprots){
    prot <- prots[i]
    unf <- peptide.traces[peptide.traces$protein_id == prot]
    sf <- peptide.traces.sf[peptide.traces.sf$protein_id == prot]
    cf <- peptide.traces.cf[peptide.traces.cf$protein_id == prot]
    matplot(t(unf), type = "l", main = paste(prot, "unfiltered"))
    if (nrow(sf) > 0){
      matplot(t(sf), type = "l", main = paste0(prot, " consec", sf_setting, "filtered"))
    } else {plot.new();mtext("removed by stretchfilter")}
    if (nrow(cf) > 0){
      matplot(t(cf), type = "l", main = paste0(prot, "corr", cf_setting, "filtered"))
    } else {plot.new();mtext("removed by corrfilter")}
  }
  dev.off()
  data.table(filter = c("none", "filterConsecutiveIdStretches", "filterByPeptideCorrelation"),
             setting = c("NA", sf_setting, cf_setting),
             nproteins = c( length(unique(peptide.traces$protein_id)),
                            length(unique(peptide.traces.sf$protein_id)),
                            length(unique(peptide.traces.cf$protein_id))),
             npeptides = c(length(unique(peptide.traces$peptide_id)),
                           length(unique(peptide.traces.sf$peptide_id)),
                           length(unique(peptide.traces.cf$peptide_id))))
}
